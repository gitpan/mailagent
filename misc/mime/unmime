: # feed this into perl
		eval 'exec perl -S $0 ${1+"$@"}'
				if $running_under_some_shell;

# $Id: unmime,v 3.0.1.1 1996/12/24 15:04:50 ram Exp $
#
#  Copyright (c) 1990-1993, Raphael Manfredi
#  
#  You may redistribute only under the terms of the Artistic License,
#  as specified in the README file that comes with the distribution.
#  You may reuse parts of this distribution only within the terms of
#  that same Artistic License; a copy of which may be found at the root
#  of the source tree for mailagent 3.0.
#
# Original Author: Eryq / eryq@rhine.gsfc.nasa.gov
#
# Integrated into mailagent and modified with Eryq's permission.
#
# $Log: unmime,v $
# Revision 3.0.1.1  1996/12/24  15:04:50  ram
# patch45: created
#

# Un-MIME regular message from stdin.
# Non-text version saved in directory ~/mail/MIME and proper indication is
# left in the dumped message. Text is otherwise dumped and deleted from there.
#
# Intended to be used with mailagent thanks to the following incantation rule:
#
# Mime-Version: /^\d/	{ SAVE +mime; FEED ~/mail/unmime; RESYNC; REJECT };
#
# WARNING: copy this script to ~/mail/unmime only when you're done with
# it since mailagent can pop up and use it anytime once the above is plugged.
#
# Options:
#   -e: pass the quoted-printable decoder over the message and that's it.

($me = $0) =~ s|.*/(.*)|$1|;

require "getopts.pl";
Getopts('e');

$TMPDIR = "$ENV{HOME}/mail/MIME";

use MIME::Parser;

#------------------------------------------------------------
# dump_entity - idempotent routine for dumping an entity
#------------------------------------------------------------

sub dump_entity {
	my ($entity) = @_;
	my $IO;
	my $not_first_part = 0;

	print $entity->head->original_text, "\n";
	# Output the body:
	my @parts = $entity->parts;
	if (@parts) {							  # multipart...
		my $i;
		foreach $i (0 .. $#parts) {			# dump each part...
			dump_entity($parts[$i]);
		}
	} else {								   # single part... 
		# Get MIME type, and display accordingly...
		my ($type, $subtype) = split('/', $entity->head->mime_type);
		my $body = $entity->bodyhandle;
		my $path = $body->path;
		if ($type =~ /^(text|message)$/ || -T $path) {	 # text: display it...
			if ($IO = $body->open("r")) {
				print "\n" if $not_first_part++;
				print $_ while (defined($_ = $IO->getline));
				$IO->close;

				# If message is text/message, chances that we did the
				# right thing are extremely high. So unlink the message
				# if lying on the disk... -- RAM, 19/11/96

				unlink($path) or warn "$me: can't unlink $path: $!\n"
					if defined $path && -f $path;

			} else {						   # d'oh!
				print "$0: couldn't find/open '$file': $!";
			}
		} else {							   # binary: just summarize it...
			my $size = ($path ? (-s $path) : '???');
			print ">>> This is a non-text message, $size bytes long.\n";
			print ">>> It is stored in ", ($path ? "'$path'" : 'core'),".\n\n";
		}
	}
	print "\n";

	1;
}

#------------------------------------------------------------
# unquote_stdin
#------------------------------------------------------------
sub unquote_stdin {
	use MIME::QuotedPrint;
	local $_;
	while (<STDIN>) {
		print decode_qp($_);
	}
	return 1;	# OK
}

#------------------------------------------------------------
# main
#------------------------------------------------------------

sub main {
	return &unquote_stdin if $opt_e;
	
	# Create a new MIME parser:
	my $parser = new MIME::Parser;
	
	# Create and set the output directory:
	$parser->output_dir($TMPDIR);
	
	# Read the MIME message:
	$entity = $parser->read(\*STDIN) or die "couldn't parse MIME stream";

	# Dump it out:
	dump_entity($entity);
}

exit(&main ? 0 : -1);

#------------------------------------------------------------
1;
